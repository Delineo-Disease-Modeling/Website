{"ast":null,"code":"import { Component } from 'react';\nimport { connect } from 'react-redux';\nimport { options, markerIcons, queries } from '../const/placeTypes.js';\nimport axios from 'axios';\n\nclass Marker extends Component {\n  constructor(props) {\n    super(props); // markers looks like {'lodging': [marker1, marker2, ...], 'restaurant': [marker1, ...], ...}\n\n    this.markers = options.reduce((options, option) => ({ ...options,\n      [option]: []\n    }), {});\n  } // Initialize once\n\n\n  componentDidMount({\n    map,\n    mapApi\n  } = this.props) {\n    this.infowindow = new mapApi.InfoWindow();\n    this.service = new mapApi.places.PlacesService(map);\n  } // Only re-render if a new search occurs or if one of the checkboxes change.\n\n\n  componentDidUpdate(prevProps) {\n    if (this.props.polygons !== prevProps.polygons) {\n      this.clearMarkers(); // TODO: loading stuff? so client doesn't get confused when searching takes forever\n      // for every polygon, user-drawn or searched, get boundaries and query from overpass\n\n      this.props.polygons.forEach(polygon => {\n        this.nearbySearch(this.props, polygon);\n      });\n    } else if (this.props.filter !== prevProps.filter) {\n      options.forEach(option => {\n        if (this.props.filter[option] !== prevProps.filter[option]) {\n          this.props.filter[option] ? this.setVisible(this.props, option) : this.setInvisible(option);\n        }\n      });\n    }\n  } // Conduct a search of the area and initialize the map with all markers + markerIcons.\n  // Show only the markers that correspond to selected checkboxes.\n\n\n  nearbySearch({\n    map,\n    mapApi\n  } = this.props, polygon) {\n    // TODO: check areaId for custom polyline for user-drawn polygons\n    let areaId = polygon['type'] === \"relation\" ? polygon['id'] + 3600000000 : polygon['id'] + 2400000000; // for every place type, make an osm overpass query\n\n    options.forEach(option => {\n      axios.get('https://overpass.kumi.systems/api/interpreter?data=' + queries[option](`area:${areaId}`)) // Overpass Kumi says we should include contact info but I think Chrome blocks us from setting User-Agent\n      //{headers: {'User-Agent': 'Delineo Disease Modeling (email: delineodiseasemodeling-at-gmail.com)'}})\n      .then(results => {\n        // get the results of the query\n        const {\n          elements\n        } = results.data; // create marker and add to array\n\n        elements.forEach(place => {\n          // TODO: plot ways and relations, not just nodes\n          if (place.type === 'node') {\n            let marker = new mapApi.Marker({\n              map: this.props.filter[option] ? map : null,\n              position: {\n                lat: place.lat,\n                lng: place.lon\n              },\n              icon: markerIcons[option]\n            });\n            this.markers[option].push(marker); // open info window when clicked\n\n            mapApi.event.addListener(marker, 'click', () => {\n              this.infowindow.setContent('<div><strong>' + place.tags.name + '</strong><br>' + JSON.stringify(place.tags) + '</div>');\n              this.infowindow.open(map, marker);\n            });\n          }\n        });\n      }).catch(err => console.log(err));\n    });\n  } // set all markers of type 'option' to visible\n\n\n  setVisible({\n    map\n  } = this.props, option) {\n    this.markers[option].forEach(m => {\n      m.setMap(map);\n    });\n  } // set all markers of type 'option' to invisible\n\n\n  setInvisible(option) {\n    this.markers[option].forEach(m => {\n      m.setMap(null);\n    });\n  } // delete markers by setting marker visibility to null and removing from markers array\n\n\n  clearMarkers() {\n    options.forEach(option => this.setInvisible(option));\n    this.markers = options.reduce((options, option) => ({ ...options,\n      [option]: []\n    }), {});\n  } // because we use google map api markers and info windows, we don't render\n  // anything ourselves. just make sure to use componentWillUpdate() for all\n  // relevant state changes\n\n\n  render() {\n    return null;\n  }\n\n}\n\nconst mapStateToProps = state => ({\n  polygons: state.polygons\n});\n\nexport default connect(mapStateToProps, null)(Marker);","map":{"version":3,"sources":["/Users/davidyang/Documents/Website/model_app/frontend/src/components/Marker.js"],"names":["Component","connect","options","markerIcons","queries","axios","Marker","constructor","props","markers","reduce","option","componentDidMount","map","mapApi","infowindow","InfoWindow","service","places","PlacesService","componentDidUpdate","prevProps","polygons","clearMarkers","forEach","polygon","nearbySearch","filter","setVisible","setInvisible","areaId","get","then","results","elements","data","place","type","marker","position","lat","lng","lon","icon","push","event","addListener","setContent","tags","name","JSON","stringify","open","catch","err","console","log","m","setMap","render","mapStateToProps","state"],"mappings":"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","sourcesContent":["import {Component} from 'react';\nimport { connect } from 'react-redux';\nimport {options, markerIcons, queries} from '../const/placeTypes.js';\nimport axios from 'axios';\n\nclass Marker extends Component {\n    constructor(props) {\n        super(props);\n        // markers looks like {'lodging': [marker1, marker2, ...], 'restaurant': [marker1, ...], ...}\n        this.markers = options.reduce((options, option) => ({\n                ...options,\n                [option]: []\n            }), {})\n    }\n\n    // Initialize once\n    componentDidMount({map, mapApi} = this.props) {\n        this.infowindow = new mapApi.InfoWindow();\n        this.service = new mapApi.places.PlacesService(map);\n    }\n\n    // Only re-render if a new search occurs or if one of the checkboxes change.\n    componentDidUpdate(prevProps) {\n        if (this.props.polygons !== prevProps.polygons) {\n            this.clearMarkers();\n\n            // TODO: loading stuff? so client doesn't get confused when searching takes forever\n            // for every polygon, user-drawn or searched, get boundaries and query from overpass\n            this.props.polygons.forEach(polygon => {\n                this.nearbySearch(this.props, polygon);\n            })\n        }\n        else if (this.props.filter !== prevProps.filter) {\n            options.forEach(option => {\n                if (this.props.filter[option] !== prevProps.filter[option]) {\n                    this.props.filter[option] ? this.setVisible(this.props, option) :\n                                            this.setInvisible(option);\n                }\n            });\n        }\n    }\n\n    // Conduct a search of the area and initialize the map with all markers + markerIcons.\n    // Show only the markers that correspond to selected checkboxes.\n    nearbySearch({ map, mapApi } = this.props, polygon) {\n        // TODO: check areaId for custom polyline for user-drawn polygons\n        let areaId = (polygon['type'] === \"relation\") ? polygon['id']+3600000000 : polygon['id']+2400000000;\n\n        // for every place type, make an osm overpass query\n        options.forEach(option => {\n            axios.get('https://overpass.kumi.systems/api/interpreter?data='+\n                queries[option](`area:${areaId}`))\n                // Overpass Kumi says we should include contact info but I think Chrome blocks us from setting User-Agent\n                //{headers: {'User-Agent': 'Delineo Disease Modeling (email: delineodiseasemodeling-at-gmail.com)'}})\n                .then(results => {\n                    // get the results of the query\n                    const {elements} = results.data;\n                    \n                    // create marker and add to array\n                    elements.forEach(place => {\n                    // TODO: plot ways and relations, not just nodes\n                    if (place.type === 'node') {\n                        let marker = new mapApi.Marker({ map:\n                            this.props.filter[option] ? map : null,\n                                    position: {lat: place.lat, lng: place.lon},\n                                    icon: markerIcons[option]\n                        });\n                        this.markers[option].push(marker);\n\n                        // open info window when clicked\n                        mapApi.event.addListener(marker, 'click', () => {\n                            this.infowindow.setContent('<div><strong>' + place.tags.name + '</strong><br>' +\n                                        JSON.stringify(place.tags) + '</div>');\n                            this.infowindow.open(map, marker);\n                            });\n                        }\n                    });\n                })\n                .catch(err => console.log(err));\n        });\n    }\n\n    // set all markers of type 'option' to visible\n    setVisible({map} = this.props, option) {\n        this.markers[option].forEach(m => { m.setMap(map); });\n    }\n\n    // set all markers of type 'option' to invisible\n    setInvisible(option) {\n        this.markers[option].forEach(m => { m.setMap(null); });\n    }\n\n    // delete markers by setting marker visibility to null and removing from markers array\n    clearMarkers() {\n        options.forEach(option => this.setInvisible(option));\n        this.markers = options.reduce((options, option) => ({\n                ...options,\n                [option]: []\n            }), {});\n    }\n\n    // because we use google map api markers and info windows, we don't render\n    // anything ourselves. just make sure to use componentWillUpdate() for all\n    // relevant state changes\n    render() {\n        return null;\n    }\n}\n\nconst mapStateToProps = (state) => ({\n    polygons: state.polygons\n});\n\nexport default connect(mapStateToProps, null)(Marker);"]},"metadata":{},"sourceType":"module"}